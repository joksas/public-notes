---
title: "The Go Programming Language"
---

These are my notes for the textbook "The Go Programming Language" by Alan Donovan and Brian Kernighan.

\clearpage

# Chapter 1

## Section 1.2

* Comments begin with `//`.
* Variables can be initialized as part of their declaration. If they are not explicitly initialized, they are implicitly initialized to *zero value*, i.e. `0` for numeric types and to an empty string for strings.
* `+` concatenates strings.
* `:=` is used for *short variable declaration*---it can declare one or more variables and give them appropriate types based on the initializer values.
* `i++` adds `1` to `i`. This is a statement, and not an expression, thus `j = i++` is illegal.

### `for` loops

#### Traditional

The `for` loop is *the only loop statement in Go*. One of its forms is
```go
for initialization; condition; post {
	// zero or more statements
}
```
For example:
```go
sum := 0
for i := 0; i < 10; i++ {
	sum += i
}
fmt.Println(sum)
```
* In the `for` loop, the opening brace must be on the same line as the `post` condition.
* `initialization` statement is executed before the loop starts.
* `condition` is a boolean expression evaluated at the beginning of each iteration.
* `post` statement is executed after the body of the loop, then the condition is evaluated again.
* The loop ends when the condition becomes false.
* Any of the `initialization`, `condition` or `post` can be omitted
* If neither of the last two are included, the semicolons can be omitted as well.

`while` loop can be constructed using `for` loop:
```go
// a traditional "while" loop
for condition {
	// ...
}
```

Similarly, and infinite loop can be constructed by omitting `condition` entirely:
```go
// a traditional infinite loop
for {
	// ...
}
```
Such a loop could still be terminated using `break` or `return` statement, for example.

#### `range`

A different form of the `for` loop can iterate over a *range* of values. For example:
```go
nums := []int{2, 0, 5, 2}
for idx, val := range nums {
	fmt.Println("index:", idx)
	fmt.Println("value", val)
}
fmt.Println(s)
```
* In each iteration, `range` produce two values: the index and the value of the element at that index.
* If one does not need an index, it can be assigned to *blank identifier*, `_`. This identifier can be used whenever syntax requires a variable name, but the program logic does not.
* If one does not need the value, it can be omitted (together with the comma)

### Declaring string variables

Here are four equivalent ways to declare a string variable:
```go
s := ""
var s string
var s = ""
var s string = ""
```
* The first one is the most compact but may only be used within a function, not for package-level variables.
* The second one relies on default initialization to an empty string.
* The third one is rarely used, except when declaring multiple variables.
* The fourth one is explicit about the variable's type, which is redundant. 

In practice, one should generally use either the first or the second form, with explicit initialization to say that the initial value is important and implicit initialization when it is not important. 

## Section 1.3

Functions and other package-level entities may be declared in any order.

### `map`

A `map` holds a set of key/value pairs. The key be of any type whose values can be compared with `==`. In the following example, function `make` creates a new empty map, in which the keys are strings and the values are `int`s:
```go
my_map := make(map[string]int)
```

One can iterate over the `map` using range:

```go
for key, val : = range my_map {
	// ...
}
```

The order of map iteration is not specified, but in practice it is random. This is intentional as it prevents programs from relying on any particular order where none is guaranteed.

`map`s are references to the data structures created by `make`. When a `map` is passed to a function, that function receives a copy of the reference. Any changes the function makes to the data structure will be visible through the caller function's `map` reference too.

### Scanners

One can create a scanner that reads from the program's standard input with the following command:
```go
input := bufio.NewScanner(os.Stdin)
```

With each call of `input.Scan()`, it reads the next line and removes the newline character from the end of the line. The result is retrieved by calling `input.Text()`. The `Scan` function return `true` when there is a line and `false` when there is not. 

Additionally, one can read files. With `os.Open(file)` one can open the file: 
```go
for _, arg := range files {
	f, err := os.Open(arg)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		continue
	}
	doThings(f)
	f.Close()
}
```

`f`, the first return value of `os.Open` is an open file that can be read by the `Scanner`. `err`, the second return value of `os.Open` is a value of the built-in error type. If `err == nil`, it means that the file was opened successfully. After the file is read, `Close` closes the file and releases any resources.

Finally, one can also read the entire input into memory at once and then manipulate it accordingly. This is done with the following piece of code:
```go
data, err := ioutil.ReadFile(filename)
```

### `Printf`

`fmt.Printf` allows to produce formatted output. Its first argument is a format string that specifies how the subsequent list of arguments should be formatted. The format of each argument is determined by a conversion character (a letter that follows a percent sign). For example, `%d` can format an integer using decimal notation. The following are some of the conversions:

| Conversion character |                       Displays argument as                      |
|:--------------------:|:---------------------------------------------------------------:|
| `%d`                 | Integer (base 10)                                               |
| `%b`                 | Integer (base 2)                                                |
| `%f`                 | Floating-point (no exponent)                                    |
| `%e`                 | Floating-point (with exponent)                                  |
| `%g`                 | Floating-point (`%e` for large exponents, `%f` otherwise)       |
| `%t`                 | Boolean                                                         |
| `%s`                 | String                                                          |
| `%c`                 | Character (represented by the corresponding Unicode code point) |
| `%q`                 | Quoted string or character                                      |
| `%v`                 | The value in a default (natural) format                         |
| `%%`                 | Literal percent sign                                            |

Additionally, there are *escape sequences* `\n` and `\t` for newline and tab, respectively. `Printf` does not write newline by default and so (by convention) don't any formatting functions whose names end in `f`, e.g. `log.Printf` or `fmt.Errorf`. Those functions whose names end in `ln` follow the logic of `Println`, i.e. formatting their arguments as if by `%v`, followed by `\n`.

## Section 1.4

### Importing packages

If we import a package whose path has multiple components, for example `image/color` and `image/gif`, in the following way
```go
import (
	"image"
	"image/color"
	"image/gif"
)
```
then we refer to the package with a name that comes from the last component. For example, `color.White` belongs to `image/color`, while `gif.GIF` belongs to `image/gif`.

### Constants

`const` declaration gives names to constants, values that are fixed at compile time. `const`s can be declared at package level (in which case their names would be visible throughout the package) or within a function. The value of a `const` must be a number, string or boolean. One can declare `const`s in the following way:
```go
const (
	myFirstConstant = 3.14
	mySecondConstant = 42
)
```

## Section 1.5

* Function `io.Copy(dst, src)` reads from `src` and writes to `dst`. One can use it for copying contents to `os.Stdout`, for example.
* Functions `strings.HasPrefix(s, prefix)` tests whether string `s` begins with `prefix`.


## Section 1.6

A *goroutine* is a concurrent function execution. This can be initiated in the following way:
```go
go myFunction(arg1, arg2) // start a goroutine
```
The function `main` runs in a goroutine as well.

A *channel* is a communication mechanism that allows one goroutine to pass values of *a specified type* to another goroutine.  To make a channel for strings:
```go
ch := make(chan string)
```
It can be received by a function:
```go
func myFunction(myChannel chan<- string) {
	myChannel <- "I am sending this message through myChannel to the caller function"
}
```
In the caller function, one can receive from the channel:
```go
fmt.Println(<-ch)
```

## Section 1.8

### Switches

Go also implements switches. For example, `switch` can operate on an operand:
```go
switch coinFlip() {
case "heads":
	heads++
case "tails":
	tails++
default:
	fmt.Println("Landed on edege.")
}
```
or it can simply list cases, each of which is a boolean expression (equivalent to `switch true`):
```go
func sumInt(x int, y int) {
	switch {
	case x + y < 0:
		fmt.Println("The sum is negative")
	default:
		fmt.Println("The sum is zero")
	case x + y > 0:
		fmt.Println("The sum is positive")
	}
}
```

`case`s are evaluated from top to bottom and the first matching is executed. The optional `default` is executed if *none* of the other cases match; it may be placed anywhere as seen in the example above. Cases do not fall through from one to the next one, though `fallthrough` statement can be used to override this behavior.

### Comments

As seen before, comments can be written with a pair of forward slashes (`//`). One can also use `/*` for the start of a block comment and `*/` for its end. However, for documenting code `//` are preferred.

# Chapter 2

## Section 2.1

In Go, the names of functions, variables, constants, types, statement labels and packages start with a letter or an underscore and may be followed by any number of additional letters, digits and underscores. The names can be set to anything, except for 25 keywords like `func` or `if`. Additionally, there are some predeclared names like `int` or `true` which can be redeclared (though that should be avoided in most cases).

If an entity is declared within a function, it is local to that function. If declared outside of a function, it is visible in all files of the package to which it belongs.

*The case of the first letter of name determines its visibility across package boundaries.* If a name begins with an uppercase letter, it is exported---it is visible outside of its own package and may be used by other parts of the program that imports that package, e.g. `fmt.Println()`. Package names are always in lowercase.

There is no limit on name length, but by convention shorter names are preferred in Go. Generally, the larger the scope of a name, the longer and more meaningful it should be.

In Go, camelCase is preferred, e.g. `MyFirstFunction()` and `mySecondFunction()` instead of `My_first_function()` and `my_second_function()`. The letters of acronyms and initialisms are always rendered in the same case, i.e. either only lowercase or only uppercase. For example, we would use `ufoGenerate()`, `UFOGenerate()`, `generateUFO()` or `GenerateUFO()`, but not `generateUfo()`.

## Section 2.2

A **declaration** names a program entity and specifies some or all of its properties. There are four major types of declarations: `var`, `const`, `type` and `func`.

A Go program is stored in or more files, all with extension `.go`. Each file begins with a package declaration that states which package the file is part of, e.g.:
```go
package main
```
After that follow `import` declarations and then package-level declarations of types, variables and functions in any order.

### Functions

A function declaration has a name, a list of parameters, an optional list of results and the function body. The result list is omitted if the function does not return anything. The function execution begins with the first statement and ends with the first encounter of a `return` statement or when the end of a function is reached that has no results. For example:
```go
func kmPerHToMPerS(kmPerH float64) float64 {
	return kmPerH * 1000 / 3600
}
```

## Section 2.3

A `var` declaration creates a variable of a particular type, attaches a name to it, and sets its initial value. In Go, there is no such thing as uninitialized variables. Go uses the zero-value mechanism to ensure that every variable holds a well-defined value of its type.

Each `var` declaration has the general form
```go
var name type = expression
```

Either `type` or `= expression` may be omitted, but not both because the variable has to be initialized:

* if `type` is omitted, the type is deduced from the initializer expression.
* if `= expression` is omitted, the initial value is set to the zero value of the specified type.

The table below lists zero values for various types.

| Type                                                       | Zero value                           |
|------------------------------------------------------------|--------------------------------------|
| All integer types                                          | `0`                                  |
| All float types                                            | `0.0`                                |
| Boolean                                                    | `false`                              |
| Strings                                                    | `""`                                 |
| Interfaces, slices, channels, maps, pointers and functions | `nil`                                |
| Array or struct                                            | Zero value for each element or field |

Go also allows to initialize more than one variable at a time. By omitting the type one can also declare variable with different types:
```go 
var a, b, c float64					// float64, float64, float64
var d, e, f = 5, 3.14, false		// int, float64, bool
```

A set of variables can also be initialized by calling a function that returns multiple values:
```go
var f, err = os.Open(name)	// a file and an error are returned
```

### Subsection 2.3.1

Inside a function, one may also use **short variable declaration** to declare and initialize variables. It has the following form:
```go
name := expression
```

The type of `name` is determined by the type of `expression`. Here is a couple of examples:
```go
anim := gif.GIF{LoopCount: nframes}
t := 0.0
```

Short variable declarations are used to declare most of local variables. `var` declaration is usually reserved for local variables that need an explicit type that differs from that of the initializer expression or when the variable will be assigned a value later and its initial value is not important.

As with `var` declarations, multiple variables can be declared using short variable declaration:
```go
i, j := 0, 1
```
but such declarations should be reserved only when they improve readability.

In Go, `:=` is declaration and `=` is assignment.

As with `var` declarations, short variable declaration may be used for calls to functions that return two or more values. However, short variable declaration does not necessarily declare all the variables on the LHS. If some of them were already declared in the same lexical block, then the short variable declaration acts like assignment to those variables. A short variable declaration must declare at least one new variable though.
```go
f, err := os.Open(infile)
// ...
out, err := os.Create(outfile) // no error because `out` newly declared
// ...
f, err := os.Create(outfile) // compile error: no new variables
```
One would have to use an ordinary assignment for the third statement.

### Subsection 2.3.2

A **variable** is a piece of storage containing a value. A **pointer** is the address of a variable, or simply the location where a value is stored.

If we declare a variable as
```go
var x int
```
then the expression `&x` yields a pointer to an integer variable. It is a value of type `*int`, which is pronounced as "pointer to `int`". If this pointer is called `p`, then we say "`p` points to `x`". The variable to which `p` points is written `*p`. It can even used in assignment and thus update the variable:
```go
x := 1
p := &x
fmt.Println(*p) // output: 1
*p = 2
fmt.Println(x) // output: 2
```

Each component of a variable of aggregate type (struct or array) is also a variable and thus has an address too.

The zero value of a pointer of any type is `nil`.
